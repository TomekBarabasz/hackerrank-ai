        - module click_o_mania
        - using DataStructures
        - export Point2D
        - export findPosition,partition,collectGroups,removeGroup,solve,updateColumn,removeColumn,makeGrid,printGrid
        - 
        - mutable struct Point2D{T}
        -     x::T
        -     y::T
        - end
        - 
        - function findPosition(c::Char, grid::Vector{String})
        -     y = 1
        -     for line in grid
        -         x = findfirst(c,line)
        -         if x â‰  nothing
        -             return x,y
        -         end
        -         y = y + 1
        -     end
        -     0,0
        - end
        - 
        - const EmptySpace = ' '
        - 
        - mutable struct Workspace
        -     groups_grid::Array{Int8,2}
        -     points::Ring{Tuple{Int8,Int8}}
        - end
        - 
        - function partition(grid::Array{Char,2})
        -     nrow,ncol = size(grid)
        -     groups = zeros(Int8,nrow,ncol)
        -     wrk = Workspace(groups, Ring{Tuple{Int8,Int8}}(nrow*ncol))
        -     #points = Vector{Tuple{Int8,Int8}}()
        -     #sizehint!(points,nrow*ncol)
        -     partition!(grid,wrk)
        -     groups
        - end
        - 
        - function partition!(grid::Array{Char,2},wrk::Workspace)
        0     nrow,ncol = size(grid)
        -     nextGroup = 1
        0     fill!(wrk.groups_grid,0)
        0     for irow in 1:nrow, icol in 1:ncol
        0         group = wrk.groups_grid[irow,icol]
        0         if group == 0 && grid[irow,icol] != EmptySpace
        -             group = nextGroup
        0             nextGroup = nextGroup + 1
        0             fillGroupFromPosition!(grid,irow,icol,group,wrk)
        -         end
        -     end
        - end
        - 
        - const Directions = [(-1,0),(0,-1),(0,1),(1,0)]
        - function fillGroupFromPosition!(grid,irow,icol,group,wrk)
        0     color = grid[irow,icol]
        0     nr,nc = size(grid)
        0     push!(wrk.points,(irow,icol))
        0     while length(wrk.points) > 0
        0         r,c = popfirst!(wrk.points)
        0         wrk.groups_grid[r,c] = group
        0         for (dr,dc) in Directions
        0             r1 = r + dr
        0             (r1 < 1 || r1 > nr) && continue
        0             c1 = c + dc
        0             (c1 < 1 || c1 > nc) && continue
        0             if grid[r1,c1] == color && wrk.groups_grid[r1,c1] == 0
        0                 push!(wrk.points,(r1,c1))
        -             end
        -         end
        -     end
        - end
        - 
        - stopCondition_slow(groups) = length(groups) == 0 || (length.(groups) .== 1) |> all
        - 
        - function stopCondition(groups)
        -     for gr in groups
        -         length(gr) > 1 && return false
        -     end
        -     true
        - end
        - 
        - function solveInternal(grid,level,groups::Union{Vector,Nothing},wrk::Workspace)
        0     if groups == nothing
        0         partition!(grid,wrk)
        0         groups = collectGroups(wrk.groups_grid)
        -     end
        0     if stopCondition(groups)
        0         return length(groups), 0
        -     else
  6253568         Pts = fill(UInt8(255),length(groups))
        0         for (gi,g) in enumerate(groups)
        0             if length(g) > 1
        0                 ngrid = removeGroup(grid,g)
        0                 pts,_ = solveInternal(ngrid,level+1,nothing,wrk)
        0                 Pts[gi] = pts
        -             end
        -         end
        0         findmin(Pts) #points, group index to remove
        -     end
        - end
        - 
        - function solve(grid)
        0     nrow,ncol = size(grid)
      384     wrk = Workspace(zeros(Int8,nrow,ncol), Ring{Tuple{Int8,Int8}}(nrow*ncol))
        0     partition!(grid,wrk)
        0     groups = collectGroups(wrk.groups_grid)
       80     _,idx = solveInternal(grid,1,groups,wrk)
        0     idx != 0 ? groups[idx][1] : nothing
        - end
        - 
        - function collectGroups(groups)
        0     dgr = Dict( v => [] for v in unique(groups) )
        0     delete!(dgr,0)
        0     nrow,ncol = size(groups)
        0     for irow in 1:nrow, icol in 1:ncol
        0         group = groups[irow,icol]
 96153872         group > 0 && push!( dgr[group], (irow,icol) )
        -     end
 10372272     values(dgr) |> collect
        - end
        - 
        - function removeGroup(grid,group)
        0     ncol = size(grid,2)
 49153440     ngrid = copy(grid)
 89041728     for (r,c) in group
        0         ngrid[r,c] = EmptySpace
        -     end
  9362560     emptyCols = Int8[]
        0     for icol in 1:ncol
  3775936         updateColumn!(ngrid,icol) && push!(emptyCols,icol)
        -     end
        0     for icol in reverse(emptyCols)
        0         removeColumn!(ngrid,icol)
        -     end
        0     ngrid
        - end
        - 
        - function updateColumn!(grid,icol)
        0     nrow = size(grid,1)
        0     for irow in 2:nrow
        0         if grid[irow,icol] == EmptySpace
512010064             grid[2:irow,icol] = grid[1:irow-1,icol]
        0             grid[1,icol] = EmptySpace
        -         end
        -     end
224701440     (grid[:,icol] .== EmptySpace) |> all
        - end
        - 
        - function updateColumn(grid,icol)
        -     ngrid = copy(grid)
        -     updateColumn!(ngrid,icol)
        -     ngrid
        - end
        - 
        - function removeColumn!(grid,icol)
        0     icol == size(grid,2) && return
        0     grid[:,icol:end-1] = grid[:,icol+1:end]
 26184480     grid[:,end] .= EmptySpace
        - end
        - 
        - function removeColumn(grid,icol)
        -     ngrid = copy(grid)
        -     removeColumn!(ngrid,icol)
        -     ngrid
        - end
        - 
        - function makeGrid(rows::Vector{String})
      896     grid = Array{Char,2}(undef,length(rows),length(rows[1]))
        0     for (irow,row) in enumerate(rows)
        0         for (icol,c) in enumerate(row)
        0             grid[irow,icol]=c
        -         end
        -     end
        0     grid
        - end
        - 
        - function printGrid(grid)
        -     grid |> eachrow .|> join .|> println
        - end
        - 
        - end
